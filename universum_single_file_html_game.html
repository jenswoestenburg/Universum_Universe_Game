<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Universum â€” EVP Collector</title>
  <style>
    :root{
      --brand:#EA5A00;
      --bg:#050816;
      --accent:#7be3ff;
      --danger:#ff3b3b;
      --power:#ffd700;
      --muted:#9bb0c8;
    }
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;background:linear-gradient(180deg,var(--bg),#07102b);color:white;overflow:hidden}
    #gameArea{position:fixed;inset:0}
    canvas{display:block;width:100%;height:100%}
    #hud{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.25);padding:10px;border-radius:10px;backdrop-filter:blur(4px);z-index:40}
    #toast{position:absolute;left:50%;top:20px;transform:translateX(-50%);background:rgba(0,0,0,0.75);padding:12px 16px;border-radius:10px;font-weight:700;display:none;z-index:45;max-width:760px;text-align:center}
    .btns{position:absolute;right:12px;top:12px;display:flex;gap:8px;z-index:40}
    button{background:var(--brand);border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:700}
  </style>
</head>
<body>
  <div id="gameArea">
    <canvas id="gameCanvas"></canvas>
    <div id="hud">Score: <span id="score">0</span> | High: <span id="highscore">0</span> | Speed: <span id="speedDisplay">1.00x</span></div>
    <div id="toast">Press SPACE or click to start â€” Use Arrow keys / WASD to move. Avoid PR disasters and scandals. Collect EVP tokens and grab High Market Cap for a boost!</div>
    <div class="btns"><button id="retry">Retry</button><button id="mute">ðŸ”Š</button></div>
  </div>

<script>
// ---------- Colors (use JS constants for canvas drawing â€” canvas doesn't accept CSS var() for fillStyle reliably) ----------
const BRAND = '#EA5A00';
const ACCENT = '#7be3ff';
const DANGER = '#ff3b3b';
const POWER = '#ffd700';
const BG = '#050816';
const WINDOW_DARK = '#062b36';

// ---------- Canvas setup ----------
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, window.devicePixelRatio || 1);
let W = 0, H = 0;
function resize(){
  W = window.innerWidth; H = window.innerHeight;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  canvas.width = Math.floor(W * DPR); canvas.height = Math.floor(H * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener('resize', resize); resize();

// ---------- Game state ----------
let score = 0;
let highscore = Number(localStorage.getItem('universum_high') || 0);
document.getElementById('highscore').innerText = highscore;
let gameState = 'start'; // 'start' | 'playing' | 'dead'
let keys = {};

// player
let player = { x: W/2, y: H*0.6, vx:0, vy:0, size:32, accel:900, maxSpeed:520, boost:1, boostTimer:0 };

// entities
let tokens = []; // EVP collectors
let obstacles = []; // PR disasters & scandals
let powerups = []; // High Market Cap

// spawn timers (seconds)
let spawnTokenTimer = 0.6;
let spawnObstacleTimer = 2.2;
let spawnPowerupTimer = 10.0;

// Difficulty scaling (gentle)
function difficulty(){ return 1 + Math.min(10, score * 0.06); }

// ---------- Input ----------
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if ((e.key === ' ' || e.key === 'Spacebar') && gameState !== 'playing') startGame(); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousedown', () => { if (gameState !== 'playing') startGame(); });

// HUD elements
const scoreEl = document.getElementById('score');
const speedDisplayEl = document.getElementById('speedDisplay');

// Buttons
document.getElementById('retry').addEventListener('click', () => startGame());
let muted = false; document.getElementById('mute').addEventListener('click', ()=>{ muted = !muted; document.getElementById('mute').innerText = muted? 'ðŸ”‡':'ðŸ”Š'; });

// ---------- Audio (simple beeps) ----------
const AudioCtx = window.AudioContext || window.webkitAudioContext; let audioCtx;
function ensureAudio(){ if(!audioCtx) audioCtx = new AudioCtx(); }
function playBeep(kind='tick'){
  if(muted) return; try{ ensureAudio(); const t = audioCtx.currentTime;
    if(kind==='tick'){ const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(700,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.05,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.14); o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.14);
    } else if(kind==='collect'){ const o1=audioCtx.createOscillator(), o2=audioCtx.createOscillator(), g=audioCtx.createGain(); o1.type='sine'; o2.type='sine'; o1.frequency.setValueAtTime(520,t); o2.frequency.setValueAtTime(720,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.12,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.36); o1.connect(g); o2.connect(g); g.connect(audioCtx.destination); o1.start(t); o2.start(t); o1.stop(t+0.36); o2.stop(t+0.36);
    } else if(kind==='power'){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sawtooth'; o.frequency.setValueAtTime(220,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.16,t+0.03); g.gain.exponentialRampToValueAtTime(0.0001,t+0.9); o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.9); }
  }catch(e){}
}

// ---------- Helpers & spawners ----------
function rand(min,max){ return min + Math.ra ndom()*(max-min); }
function spawnToken(){ const size = 16 + Math.random()*8; const vx = rand(-10,10); const vy = rand(30,60); tokens.push({ x: rand(40, W-40), y: -size, vx, vy, size }); }
function spawnObstacle(){ const size = 28 + Math.random()*24; const label = Math.random()<0.5 ? 'PR disaster' : 'Scandal'; const vy = rand(30,55); obstacles.push({ x: rand(60, W-60), y: -size, vy, size, label }); }
function spawnPowerup(){ const size = 24; const vy = rand(28,45); powerups.push({ x: rand(80, W-80), y: -size, vy, size, label: 'High Market Cap' }); }

// ---------- Collisions ----------
function circleCollide(a,b){ const dx = a.x - b.x, dy = a.y - b.y; return (dx*dx + dy*dy) < ((a.size + b.size) * (a.size + b.size)); }

// ---------- Drawing helpers ----------
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

function drawRocket(x,y,size,angle=0){ ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
  // body (brand color)
  ctx.fillStyle = BRAND; ctx.beginPath(); ctx.moveTo(0,-size*0.9); ctx.quadraticCurveTo(size*0.6,-size*0.2,0,size*1.05); ctx.quadraticCurveTo(-size*0.6,-size*0.2,0,-size*0.9); ctx.fill();
  // window
  ctx.fillStyle = WINDOW_DARK; ctx.beginPath(); ctx.arc(0,-size*0.22,size*0.34,0,Math.PI*2); ctx.fill();
  // fins
  ctx.fillStyle = '#ffd8c9'; ctx.beginPath(); ctx.moveTo(-size*0.42,size*0.08); ctx.lineTo(-size*1.0,size*0.5); ctx.lineTo(-size*0.18,size*0.72); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(size*0.42,size*0.08); ctx.lineTo(size*1.0,size*0.5); ctx.lineTo(size*0.18,size*0.72); ctx.closePath(); ctx.fill();
  // flame
  ctx.fillStyle = 'rgba(255,184,107,0.95)'; ctx.beginPath(); ctx.ellipse(0,size*0.9,size*0.3,size*0.44,0,0,Math.PI*2); ctx.fill();
  ctx.restore(); }

function drawToken(t){ // glow + EVP
  const g = ctx.createRadialGradient(t.x, t.y, t.size*0.15, t.x, t.y, t.size*1.8);
  g.addColorStop(0, 'rgba(255,255,255,0.95)'); g.addColorStop(0.16, 'rgba(255,240,200,0.95)'); g.addColorStop(1, 'rgba(234,90,0,0.06)');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(t.x, t.y, t.size, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = WINDOW_DARK; ctx.font = '700 12px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('EVP', t.x, t.y);
}

function drawObstacle(o){ const w = Math.max(86, o.size*2.4); const h = Math.max(32, o.size*0.9); const x = o.x - w/2, y = o.y - h/2, r = 10; ctx.fillStyle = DANGER; roundRect(ctx,x,y,w,h,r); ctx.fill(); ctx.fillStyle = '#fff'; ctx.font = '700 12px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(o.label, o.x, o.y); }

function drawPowerup(p){ ctx.beginPath(); ctx.fillStyle = POWER; ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = WINDOW_DARK; ctx.font = '700 11px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('High', p.x, p.y - 6); ctx.fillText('Market Cap', p.x, p.y + 8); }

function drawBackground(ts){ // soft gradient and some parallax stars
  const grad = ctx.createLinearGradient(0,0,0,H); grad.addColorStop(0, '#061026'); grad.addColorStop(1, '#081633'); ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);
  const layers = 3; for(let i=0;i<layers;i++){ const count = 18 + i*18; for(let j=0;j<count;j++){ const x = ( (j*37 + Math.floor(ts / (1000 + i*380) )* (i+1)*17) % W ); const y = ( (j*23 + i*41) % H ); const r = 0.35 + i*0.35; ctx.globalAlpha = 0.9 - i*0.25; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); } } ctx.globalAlpha = 1; }

// ---------- Game logic ----------
let lastTime = performance.now();

function startGame(){ score = 0; updateHUD(); gameState = 'playing'; player.x = W/2; player.y = H*0.6; player.vx = 0; player.vy = 0; player.boost = 1; player.boostTimer = 0; tokens = []; obstacles = []; powerups = []; spawnTokenTimer = 0.8; spawnObstacleTimer = 2.2; spawnPowerupTimer = 10.0; document.getElementById('toast').style.display = 'none'; playBeep('power'); // seed a few gently
  for(let i=0;i<4;i++) spawnToken(); }

function endGame(){ if(gameState === 'dead') return; gameState = 'dead'; if(score > highscore){ highscore = score; localStorage.setItem('universum_high', highscore); document.getElementById('highscore').innerText = highscore; } const t = document.getElementById('toast'); t.innerText = 'Game Over â€” Score: ' + score + ' â€” Press Space or Click to try again'; t.style.display = 'block'; playBeep('tick'); }

function updateHUD(){ scoreEl.innerText = score; speedDisplayEl.innerText = (1 + score*0.04 + (player.boost>1?player.boost-1:0)).toFixed(2) + 'x'; }

function update(dt){ if(gameState !== 'playing') return; const diff = difficulty();
  // input
  let ax = 0, ay = 0; const thrust = player.accel * (player.boost || 1);
  if(keys['arrowleft'] || keys['a']) ax -= thrust; if(keys['arrowright'] || keys['d']) ax += thrust; if(keys['arrowup'] || keys['w']) ay -= thrust; if(keys['arrowdown'] || keys['s']) ay += thrust;
  // apply
  player.vx += ax * dt; player.vy += ay * dt;
  // clamp speed
  const maxSpeed = player.maxSpeed * Math.min(2.6, 1 + diff*0.06);
  const sp = Math.hypot(player.vx, player.vy);
  if(sp > maxSpeed){ player.vx = player.vx / sp * maxSpeed; player.vy = player.vy / sp * maxSpeed; }
  // damping
  player.vx *= Math.max(0, 1 - 5 * dt); player.vy *= Math.max(0, 1 - 5 * dt);
  player.x += player.vx * dt; player.y += player.vy * dt;
  // bounds
  player.x = Math.max(player.size, Math.min(W - player.size, player.x)); player.y = Math.max(player.size, Math.min(H - player.size, player.y));
  // boost decay
  if(player.boostTimer > 0){ player.boostTimer -= dt; if(player.boostTimer <= 0) player.boost = 1; }

  // spawn timers (slower, friendlier pace)
  spawnTokenTimer -= dt; spawnObstacleTimer -= dt; spawnPowerupTimer -= dt;
  const tokenBase = Math.max(0.9, 1.4 - diff*0.03);
  const obstacleBase = Math.max(1.6, 2.6 - diff*0.04);
  const powerupBase = Math.max(6.5, 10 - diff*0.2);
  if(spawnTokenTimer <= 0){ spawnToken(); spawnTokenTimer = tokenBase * (0.9 + Math.random()*0.6); }
  if(spawnObstacleTimer <= 0){ spawnObstacle(); spawnObstacleTimer = obstacleBase * (0.9 + Math.random()*0.6); }
  if(spawnPowerupTimer <= 0){ spawnPowerup(); spawnPowerupTimer = powerupBase * (0.6 + Math.random()*0.8); }

  // update tokens
  for(let i = tokens.length - 1; i >= 0; i--){ const t = tokens[i]; t.y += t.vy * dt; t.x += (t.vx || 0) * dt; if(circleCollide(player, t)){ tokens.splice(i,1); const gained = 1 + Math.floor(diff*0.12); score += gained; player.boost = Math.min(1.25, player.boost + 0.035); updateHUD(); playBeep('collect'); } else if(t.y - t.size > H) tokens.splice(i,1); }
  // update obstacles
  for(let i = obstacles.length - 1; i >= 0; i--){ const o = obstacles[i]; o.y += o.vy * dt; if(circleCollide(player, o)){ endGame(); return; } else if(o.y - o.size > H) obstacles.splice(i,1); }
  // update powerups
  for(let i = powerups.length - 1; i >= 0; i--){ const p = powerups[i]; p.y += p.vy * dt; if(circleCollide(player, p)){ powerups.splice(i,1); player.boost = 1.8; player.boostTimer = 5 + Math.random()*3; score += 5; updateHUD(); playBeep('power'); } else if(p.y - p.size > H) powerups.splice(i,1); }

  // HUD
  updateHUD(); }

// ---------- Draw ----------
function draw(now){ drawBackground(now || performance.now());
  // tokens
  for(const t of tokens) drawToken(t);
  // obstacles
  for(const o of obstacles) drawObstacle(o);
  // powerups
  for(const p of powerups) drawPowerup(p);
  // player
  drawRocket(player.x, player.y, player.size, Math.sin(Date.now() / 180) * 0.06);
}

// ---------- Main loop ----------
function loop(time){ const dt = Math.min(0.05, (time - lastTime) / 1000); lastTime = time; update(dt); draw(time); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// ---------- Initial UI & helpers ----------
const toastEl = document.getElementById('toast'); function showToast(msg, ms = 6000){ toastEl.innerText = msg; toastEl.style.display = 'block'; clearTimeout(toastEl._t); toastEl._t = setTimeout(()=>{ toastEl.style.display = 'none'; }, ms); }
showToast('Press SPACE or click to start â€” Use Arrow keys / WASD to move. Avoid PR disasters and scandals. Collect EVP tokens and grab High Market Cap for a boost!', 7000);

// seed a few items for visual niceness
function seedInitial(){ for(let i=0;i<5;i++) spawnToken(); for(let i=0;i<2;i++) spawnObstacle(); }
seedInitial();

</script>
</body>
</html>
